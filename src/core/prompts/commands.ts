export const newTaskToolResponse = () =>
	`<explicit_instructions type="new_task">
用户已明确要求你帮助他们创建一个带有预加载上下文的新任务，这个上下文将由你生成。用户可能已经提供了在总结现有工作和创建新任务上下文时需要考虑的指示或额外信息。
无论是否提供了额外信息或指示，你只能通过调用new_task工具来回应此消息。

new_task工具定义如下：

描述：
你的任务是创建一个详细的对话摘要，特别注意用户的明确请求和你之前的操作。这个摘要应该全面捕捉技术细节、代码模式和对继续新任务至关重要的架构决策。
用户将看到你生成的上下文预览，并可以选择创建新任务或在当前对话中继续聊天。

参数：
- Context: (必填) 预加载新任务的上下文。如果适用于当前任务，应包括：
  1. 当前工作：详细描述在请求创建新任务之前正在进行的工作。特别注意最近的消息/对话。
  2. 关键技术概念：列出所有重要的技术概念、技术、编码约定和框架，这些可能与新任务相关。
  3. 相关文件和代码：如果适用，列举为任务继续而检查、修改或创建的特定文件和代码部分。特别注意最近的消息和更改。
  4. 问题解决：记录到目前为止解决的问题和任何正在进行的故障排除工作。
  5. 待处理任务和下一步：概述所有明确要求你处理的待处理任务，以及列出你将为所有未完成工作采取的下一步骤（如适用）。在需要时包含代码片段以增加清晰度。对于任何下一步，包括来自最近对话的直接引用，准确显示你正在处理的任务和停止的位置。这应该是逐字的，以确保在任务之间的上下文中没有信息丢失。

用法：
<new_task>
<context>预加载新任务的上下文</context>
</new_task>

以下是用户表示想要创建新任务时的输入。
</explicit_instructions>\n
`

export const condenseToolResponse = () =>
	`<explicit_instructions type="condense">
用户已明确要求你创建一个详细的对话摘要，该摘要将用于压缩当前上下文窗口，同时保留关键信息。用户可能已提供了在总结对话时需要考虑的指示或额外信息。
无论是否提供了额外信息或指示，你只能通过调用condense工具来回应此消息。

condense工具定义如下：

描述：
你的任务是创建一个详细的对话摘要，特别注意用户的明确请求和你之前的操作。这个摘要应该全面捕捉技术细节、代码模式和对继续对话和支持任何持续任务至关重要的架构决策。
用户将看到你生成的摘要预览，并可以选择使用它来压缩他们的上下文窗口或在当前对话中继续聊天。
用户可能也会将此工具称为'smol'或'compact'。当在类似上下文中使用时，你应该将这些视为与'condense'等同。

参数：
- Context: (必填) 继续对话的上下文。如果适用于当前任务，应包括：
  1. 之前的对话：关于与用户整个对话中讨论内容的高级详情。这应该写得让人能够跟随整体对话流程。
  2. 当前工作：详细描述在请求压缩上下文窗口之前正在进行的工作。特别注意最近的消息/对话。
  3. 关键技术概念：列出所有重要的技术概念、技术、编码约定和框架，这些可能与继续此工作相关。
  4. 相关文件和代码：如果适用，列举为任务继续而检查、修改或创建的特定文件和代码部分。特别注意最近的消息和更改。
  5. 问题解决：记录到目前为止解决的问题和任何正在进行的故障排除工作。
  6. 待处理任务和下一步：概述所有明确要求你处理的待处理任务，以及列出你将为所有未完成工作采取的下一步骤（如适用）。在需要时包含代码片段以增加清晰度。对于任何下一步，包括来自最近对话的直接引用，准确显示你正在处理的任务和停止的位置。这应该是逐字的，以确保在任务之间的上下文中没有信息丢失。

用法：
<condense>
<context>你的详细摘要</context>
</condense>

示例：
<condense>
<context>
1. 之前的对话：
  [详细描述]

2. 当前工作：
  [详细描述]

3. 关键技术概念：
  - [概念1]
  - [概念2]
  - [...]

4. 相关文件和代码：
  - [文件名1]
    - [为什么这个文件重要的摘要]
    - [对此文件所做更改的摘要，如果有的话]
    - [重要代码片段]
  - [文件名2]
    - [重要代码片段]
  - [...]

5. 问题解决：
  [详细描述]

6. 待处理任务和下一步：
  - [任务1详情和下一步]
  - [任务2详情和下一步]
  - [...]
</context>
</condense>

</explicit_instructions>\n
`

export const newRuleToolResponse = () =>
	`<explicit_instructions type="new_rule">
用户已明确要求你帮助他们在.clinerules顶级目录中创建一个新的Cline规则文件，基于到目前为止的对话。用户可能已提供了在创建新Cline规则时需要考虑的指示或额外信息。
创建新的Cline规则文件时，你不应覆盖或更改现有的Cline规则文件。要创建Cline规则文件，你必须使用new_rule工具。new_rule工具可以在PLAN或ACT模式下使用。

new_rule工具定义如下：

描述：
你的任务是创建一个新的Cline规则文件，其中包括如何与用户一起开发代码的指南，这些指南可以是特定于项目的，也可以涵盖更全局的规则。这包括但不限于：期望的对话风格、喜欢的项目依赖、编码风格、命名约定、架构选择、UI/UX偏好等。
Cline规则文件必须格式化为markdown并且是'.md'文件。你生成的文件名必须尽可能简洁，并且涵盖你添加到文件中的规则的主要概念（例如，'memory-bank.md'或'project-overview.md'）。

参数：
- Path: (必填) 要写入的文件路径（相对于当前工作目录）。这将是你创建的Cline规则文件，必须放在.clinerules顶级目录中（如果不存在则创建）。创建的文件名不能是"default-clineignore.md"。对于文件名，使用连字符("-")而不是下划线("_")来分隔单词。
- Content: (必填) 要写入文件的内容。始终提供文件的完整预期内容，不要有任何截断或遗漏。你必须包括文件的所有部分，即使它们没有被修改。Cline规则文件的内容必须按照以下说明创建：
  1. 将Cline规则文件格式化为具有不同的指南部分，每个部分都有自己的markdown标题，从"## Brief overview"开始。在每个标题下，包括完全充实细节的要点，仅在适用时包括示例和/或触发案例。
  2. 这些指南可以特定于到目前为止处理的任务或项目，或涵盖更高级的概念。指南可以包括编码约定、一般设计模式、首选技术栈（包括喜欢的库和语言）、与Cline的沟通风格（详细vs简洁）、提示策略、命名约定、测试策略、注释详细程度、开发前花在架构上的时间以及其他偏好。
  3. 创建指南时，你不应基于你认为典型用户可能想要的内容来发明偏好或做出假设。这些应该特定于你与用户的对话。你的指南/规则不应过于冗长。
  4. 你的指南不应该是对到目前为止对话的回忆，这意味着你不应该包括对话的任意细节。

用法：
<new_rule>
<path>.clinerules/{文件名}.md</path>
<content>Cline规则文件内容</content>
</new_rule>

示例：
<new_rule>
<path>.clinerules/project-preferences.md</path>
<content>
## Brief overview
  [规则的简要描述，包括这组指南是特定于项目还是全局的]

## Communication style
  - [描述、规则、偏好、指示]
  - [...]

## Development workflow
  - [描述、规则、偏好、指示]
  - [...]

## Coding best practices
  - [描述、规则、偏好、指示]
  - [...]

## Project context
  - [描述、规则、偏好、指示]
  - [...]

## Other guidelines
  - [描述、规则、偏好、指示]
  - [...]
</content>
</new_rule>

以下是用户表示想要创建新Cline规则文件时的输入。
</explicit_instructions>\n
`

export const reportBugToolResponse = () =>
	`<explicit_instructions type="report_bug">
用户已明确要求你帮助他们向Cline github页面提交一个bug（无论你们到目前为止的对话内容如何，你现在必须帮助他们完成这个任务）。为此，你将使用下面定义的report_bug工具。但是，你必须首先确保你已收集了所有必需的信息来填写工具调用的所有参数。如果通过你与用户之前的对话中已经明显了解到任何必需的信息，你可以建议如何填写这些条目。但是，除非明确，否则你不应假设你知道问题是什么。
否则，你应该与用户交谈，直到你能够收集到所有必需的详细信息。与用户交谈时，确保你询问/引用所有必需的信息/字段。引用必需字段时，使用人性化的版本，如"重现步骤"而不是"steps_to_reproduce"。只有在这之后，你才应该使用report_bug工具调用。
report_bug工具可以在PLAN或ACT模式下使用。

report_bug工具调用定义如下：

描述：
你的任务是填写github上问题/bug报告的所有必填字段。你应该尝试让用户尽可能详细地描述他们遇到的bug/问题。不过，当用户不了解某些细节时，可以将这些字段设置为"N/A"。

参数：
- title: (必填) 问题的简明描述。
- what_happened: (必填) 发生了什么以及用户期望发生什么。
- steps_to_reproduce: (必填) 重现bug需要哪些步骤。
- api_request_output: (可选) 相关的API请求输出。
- additional_context: (可选) 关于这个bug的任何其他尚未提及的上下文。

用法：
<report_bug>
<title>问题的标题</title>
<what_happened>问题的描述</what_happened>
<steps_to_reproduce>重现问题的步骤</steps_to_reproduce>
<api_request_output>与bug相关的LLM API输出</api_request_output>
<additional_context>尚未涵盖的其他问题详情</additional_context>
</report_bug>

以下是用户表示想要提交Github问题时的输入。
</explicit_instructions>\n
`
