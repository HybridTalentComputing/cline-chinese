---
title: "新建任务工具"
---

### `new_task` 工具与上下文管理策略

#### 概述

Cline 包含一个强大的内部工具 `new_task`，旨在帮助管理工作流连续性和上下文保存，特别是在复杂或长时间运行的任务中。此工具与 Cline 对自身上下文窗口使用情况的感知以及 `.clinerules` 的灵活性相结合，使得能够实施复杂的分解工作和确保任务会话之间无缝过渡的策略。

理解核心能力以及它们如何与自定义规则交互，是有效利用此功能的关键。

#### 核心能力

两个基本能力实现了高级上下文管理：

1. **`new_task` 工具：**
    - **功能：** 允许 Cline 在用户批准后结束当前任务会话并立即开始新任务。
    - **上下文预加载：** 关键是，Cline 可以**预加载**带有工具 `<context>` 块中提供的特定上下文的新任务会话。此上下文可以是 Cline 或 `.clinerules` 文件定义的任何内容——摘要、代码片段、后续步骤、项目状态等。
2. **上下文窗口感知：**
    - **跟踪：** Cline 在任务期间内部跟踪其可用上下文窗口当前被使用的百分比。
    - **可见性：** 此信息在提供给 Cline 的 `environment_details` 中可见。

#### 使用 `/newtask` 斜杠命令

作为 Cline 建议使用 `newtask` 工具或定义复杂规则的快速替代方案，你可以直接使用斜杠命令启动该过程。

-   **如何使用：** 只需在聊天输入字段中输入 `/newtask`。
-   **操作：** Cline 将提议创建新任务，通常基于当前会话建议上下文（类似于使用工具时的默认行为）。你仍然会收到 `ask_followup_question` 提示以确认并在创建新任务之前可能修改上下文。
-   **好处：** 提供快速、用户发起的方式来利用 `new_task` 功能进行分支探索或管理长时间会话，而无需等待 Cline 建议它。

<Note>
	有关使用 `/newtask` 斜杠命令的更多详细信息，请参阅[新任务命令](/features/slash-commands/new-task)文档。
</Note>

#### 默认行为（没有 `.clinerules`）

默认情况下，在没有特定的 `.clinerules` 指示其行为的情况下：

-   **工具可用性：** `new_task` 工具存在，Cline_可以_选择使用它。
-   **上下文感知：** Cline_确实_知道其上下文使用百分比。
-   **无自动触发：** Cline_不会_仅根据上下文使用达到特定百分比（如 50%）就自动启动任务交接。使用 `new_task` 的决定来自 AI 模型基于整体任务进度和提示指令的推理。
-   **基本上下文预加载：** 如果使用 `new_task` 而没有定义 `<context>` 块结构的特定规则，Cline 将尝试基于其当前理解预加载相关信息（例如，进度和后续步骤的基本摘要），但这可能不如规则驱动的方法全面。

#### `.clinerules` 的力量：启用自定义工作流

虽然默认情况下存在核心能力，但当你将 `new_task` 和上下文感知与 `.clinerules` 中定义的自定义工作流结合时，真正的力量、自动化和定制化才会显现出来。这使你能够精确控制 Cline_何时_以及_如何_管理上下文和任务连续性。

将 `.clinerules` 与 `new_task` 一起使用的关键好处：

-   **自动上下文管理：** 定义规则以在特定上下文百分比（例如，>50%、>70%）或令牌计数时自动触发交接，确保最佳性能并防止上下文丢失。
-   **模型特定优化：** 基于不同 LLM 的已知阈值定制交接触发器（例如，对于已知超过特定令牌计数后性能下降的模型提前触发）。
-   **智能断点：** 通过规则指示 Cline 在通过上下文阈值_后_找到逻辑停止点（例如，完成函数或测试后），确保更清晰的交接。
-   **结构化任务分解：** 使用计划模式定义子任务，然后使用 `.clinerules` 让 Cline 在完成每个子任务后通过 `new_task` 自动创建新任务，为_下一个_子任务预加载上下文。
-   **自定义上下文打包：** 在 `.clinerules` 中规定 `<context>` 块的精确结构和内容，以实现高度详细和一致的交接（参见下面的示例）。
-   **改进的内存持久性：** 使用 `new_task` 上下文块作为跨会话持久化信息的主要、集成方式，可能替代或补充基于文件的内存系统。
-   **工作流自动化：** 为特定场景定义规则，比如在启动特定类型的任务时总是预加载某些设置说明或项目模板。

#### 示例规则驱动工作流：任务交接过程

一种常见的工作流，**由特定的 `.clinerules` 驱动，如下面的示例**，涉及以下步骤：

1. **触发器识别（基于规则）：** Cline 监视规则中定义的交接点（例如，上下文使用 > 50%、任务完成）。
2. **用户确认：** Cline 使用 `ask_followup_question` 提议创建新任务，通常显示规则定义的预期上下文。

    ```xml
    <ask_followup_question>
    <question>我已经完成 [具体成就]，上下文使用率很高（XX%）。你希望我创建一个新任务以继续 [剩余工作]，预加载以下上下文吗？</question>
    <options>["是的，创建新任务", "先修改上下文", "不，继续此会话"]</options>
    </ask_followup_question>
    ```

3. **用户控制：** 你可以在创建新任务之前批准、拒绝或要求 Cline 修改上下文。
4. **上下文打包（`new_task` 工具）：** 如果获得批准，Cline 使用 `new_task`，根据 `.clinerules` 规定的结构打包上下文。
5. **新任务创建：** 当前任务结束，新会话立即开始，预加载指定的上下文。

#### 交接上下文块（规则定义的结构）

规则驱动交接的有效性在很大程度上取决于 `.clinerules` 如何定义 `<context>` 块。全面的结构通常包括：

-   **`## 已完成的工作`**：成就、修改/创建的文件、关键决策的详细列表。
-   **`## 当前状态`**：项目状态、正在运行的进程、关键文件状态。
-   **`## 后续步骤`**：剩余任务的清晰、优先级列表、实现细节、已知挑战。
-   **`## 参考信息`**：链接、代码片段、模式、用户偏好。
-   **可操作的开始**：立即下一步操作的清晰指令。

#### 潜在用例和工作流

`new_task` 与 `.clinerules` 结合的灵活性开辟了许多可能性：

-   **主动上下文窗口管理：** 在特定百分比（例如，50%、70%）或令牌计数时自动触发交接以维持最佳性能。
-   **智能断点：** 指示 Cline 在通过上下文阈值_后_找到逻辑停止点（例如，完成函数或测试后），确保更清晰的交接。
-   **结构化任务分解：** 使用计划模式定义子任务，然后使用 `.clinerules` 让 Cline 在完成每个子任务后通过 `new_task` 自动创建新任务。
-   **自动会话摘要：** 配置 `<context>` 块以始终包含前一次会话关键讨论点的摘要。
-   **预加载模板/设置：** 启动与特定项目相关的新任务时预加载标准设置说明或文件模板。
-   **"内存库"替代方案：** 使用 `new_task` 上下文块作为跨会话持久化信息的主要方式，可能替代基于文件的内存系统。

鼓励使用 `.clinerules` 进行实验，以发现最适合你需求的工作流！

#### 示例 `.clinerules`：任务交接策略指南

下面是一个专门专注于使用 `new_task` 进行上下文窗口管理的示例 `.clinerules` 文件。**请记住，这只是一种特定策略；核心 `new_task` 工具可以与其他自定义规则以不同方式使用。**

````markdown
# 你必须使用 `new_task` 工具：任务交接策略指南

**关键指令 - 你必须遵循这些指南**

本指南提供了有效分解复杂任务和实施任务之间平滑交接过程的**强制性**说明。你**必须**遵循这些指南以确保连续性、上下文保存和高效的任务完成。

## 上下文窗口监控 - 必需操作

你**必须**监控环境详情中显示的上下文窗口使用情况。当使用超过可用上下文窗口的 50% 时，你**必须**使用 `new_task` 工具启动任务交接。

上下文窗口使用超过 50% 且具有 200K 上下文窗口的示例：

\`\`\`text

# 上下文窗口使用

105,000 / 200,000 tokens (53%)
模型：anthropic/claude-sonnet-4 (200K 上下文窗口)
\`\`\`

**重要**：当你看到上下文窗口使用率达到或超过 50% 时，你必须：

1. 完成当前逻辑步骤
2. 使用 `ask_followup_question` 工具提议创建新任务
3. 如果获得批准，使用 `new_task` 工具提供全面的交接说明

## 计划模式中的任务分解 - 必需流程

计划模式专门设计用于分析复杂任务并将其分解为可管理的子任务。在计划模式下，你必须：

### 1. 初始任务分析 - 必需

-   **必须**通过彻底理解用户请求的全部范围开始
-   **必须**识别任务的所有主要组件和依赖项
-   **必须**考虑潜在挑战、边缘情况和先决条件

### 2. 战略任务分解 - 必需

-   **必须**将整体任务分解为逻辑的、离散的子任务
-   **必须**基于依赖项对子任务进行优先级排序（必须先完成什么）
-   **必须**以在单次会话内可以完成的子任务为目标（15-30 分钟的工作）
-   **必须**考虑上下文切换有意义的自然断点

### 3. 创建任务路线图 - 必需

-   **必须**向用户呈现清晰的、编号的子任务列表
-   **必须**解释子任务之间的依赖关系
-   **必须**在可能的情况下为每个子任务提供时间估算
-   **必须**在有帮助时使用 Mermaid 图表可视化任务流程和依赖关系

\`\`\`mermaid
graph TD
A[主任务] --> B[子任务 1：设置]
A --> C[子任务 2：核心实现]
A --> D[子任务 3：测试]
A --> E[子任务 4：文档]
B --> C
C --> D
\`\`\`

### 4. 获取用户批准 - 必需

-   **必须**要求用户对提议的任务分解提供反馈
-   **必须**根据用户优先级或额外要求调整计划
-   **必须**确认从哪个子任务开始
-   **必须**请求用户在准备好实施时切换到执行模式

## 任务实施和交接过程 - 必需程序

在执行模式中实施任务时，你必须遵循以下指南以实现有效的任务交接：

### 1. 专注实施 - 必需

-   **必须**专注于完全完成当前子任务
-   **必须**通过注释和提交消息清晰地记录进度
-   **必须**在逻辑完成点创建检查点

### 2. 识别完成点 - 关键

当以下情况时，你必须识别自然的交接点：

-   当前子任务已完全完成
-   你在更大的子任务中达到了逻辑停止点
-   实施时间比预期长，可以稍后继续
-   任务范围已超出原始计划
-   **关键**：上下文窗口使用超过 50%（例如，对于 200K 上下文窗口为 100,000+ 令牌）

### 3. 启动交接过程 - 必需操作

当你达到完成点时，你必须：

1. 总结到目前为止已完成的工作
2. 清楚说明还有什么待完成
3. **必需**：使用 `ask_followup_question` 工具提议创建新任务：

\`\`\`xml
<ask_followup_question>
<question>我已经完成 [具体成就]。你希望我创建一个新任务以继续 [剩余工作] 吗？</question>
<options>["是的，创建一个新任务", "不，继续此会话", "让我考虑一下"]</options>
</ask_followup_question>
\`\`\`

### 4. 创建带有上下文的新任务 - 必需操作

如果用户同意创建新任务，你必须使用 `new_task` 工具提供全面的交接说明：

\`\`\`xml
<new_task>
<context>

# 任务继续：[简要任务标题]

## 已完成的工作

-   [已完成项目的详细列表]
-   [包括修改/创建的特定文件]
-   [注意所做的任何重要决策]

## 当前状态

-   [项目当前状态的描述]
-   [任何正在运行的进程或环境设置]
-   [关键文件及其当前状态]

## 后续步骤

-   [剩余任务的详细列表]
-   [要解决的特定实现细节]
-   [需要注意的任何已知挑战]

## 参考信息

-   [相关文档的链接]
-   [要遵循的重要代码片段或模式]
-   [当前会话中注意的任何用户偏好]

请通过 [特定下一步操作] 继续实施。
</context>
</new_task>
\`\`\`

### 5. 详细上下文传输 - 必需组件

创建新任务时，你必须始终包括：

#### 项目上下文 - 必需

-   **必须**包括项目的整体目标和目的
-   **必须**包括关键架构决策和模式
-   **必须**包括技术栈和依赖项

#### 实现细节 - 必需

-   **必须**列出在当前会话中创建或修改的文件
-   **必须**描述实现的特定函数、类或组件
-   **必须**解释遵循的设计模式
-   **必须**概述测试方法

#### 进度跟踪 - 必需

-   **必须**提供已完成项目的检查清单
-   **必须**提供剩余项目的检查清单
-   **必须**注意遇到的任何阻碍因素或挑战

#### 用户偏好 - 必需

-   **必须**注意用户提到的编码风格偏好
-   **必须**记录用户要求的特定方法
-   **必须**突出用户识别的优先级领域

## 有效交接的最佳实践 - 必需指南

### 1. 保持连续性 - 必需

-   **必须**在任务之间使用一致的术语
-   **必须**引用以前的决策及其理由
-   **必须**保持相同的架构方法，除非明确改变方向

### 2. 保存上下文 - 必需

-   **必须**在交接中包括相关的代码片段
-   **必须**总结前一次会话的关键讨论
-   **必须**在适用时引用特定文件和行号

### 3. 设置清晰的后续操作 - 必需

-   **必须**以清晰、可操作的下一步开始交接
-   **必须**对剩余任务进行优先级排序
-   **必须**突出需要做出的任何决策

### 4. 记录假设 - 必需

-   **必须**清楚说明在实施过程中所做的任何假设
-   **必须**注意可能需要用户输入的区域
-   **必须**识别潜在的替代方法

### 5. 优化可恢复性 - 必需

-   **必须**构建交接以便下次会话可以立即开始工作
-   **必须**如果需要环境配置则包括设置说明
-   **必须**在顶部提供快速摘要以快速恢复上下文

## 示例任务交接

### 有效任务交接的示例 #1：

\`\`\`xml
<new_task>
<context>

# 任务继续：实现用户认证系统

## 已完成的工作

-   创建了基本的 Express.js 服务器结构
-   实现了 MongoDB 连接和用户架构
-   完成了带有密码哈希的用户注册端点
-   使用 Joi 添加了输入验证
-   为注册端点创建了初始测试套件

## 当前状态

-   服务器在端口 3000 上成功运行
-   MongoDB 连接已建立
-   注册端点 (/api/users/register) 完全可用
-   测试套件通过了所有注册场景

## 后续步骤

1. 实现登录端点 (/api/users/login)
    - 使用 bcrypt 比较密码
    - 成功登录后生成 JWT 令牌
    - 为无效凭据添加适当的错误处理
2. 创建认证中间件
    - 验证 JWT 令牌
    - 提取用户信息
    - 处理过期令牌
3. 添加需要认证的受保护路由
4. 实现密码重置功能

## 参考信息

-   JWT 密钥应存储在 .env 文件中
-   遵循 routes/users.js 中的现有错误处理模式
-   用户架构定义在 models/User.js 中
-   测试模式在 tests/auth.test.js 中已建立

请通过实施登录端点继续，遵循注册端点中建立的相同模式。
</context>
</new_task>
\`\`\`

### 无效任务交接的示例 #2：

_（注意：原始规则中提供的显示"YOLO MODE Implementation"的示例似乎不太像直接的交接上下文块，而更像是一个带有未来考虑的一般状态更新。真正的无效交接可能在"当前状态"或"后续步骤"中缺乏细节。）_

## 何时使用任务交接 - 必需触发器

你必须在以下场景中启动任务交接：

1. **关键**：当上下文窗口使用超过 50% 时（例如，对于 200K 上下文窗口为 100,000+ 令牌）
2. 超过单次会话的**长时间运行项目**
3. 具有多个不同阶段的**复杂实施**
4. 当**上下文窗口限制**正在接近时
5. 在大型项目内**切换关注领域**时
6. 当任务的不同部分可能受益于**不同专业知识**时

**最终提醒 - 关键指令**

你必须监控环境详情部分中的上下文窗口使用情况。当它超过 50%（例如，"105,000 / 200,000 tokens (53%)"）时，你必须使用 `ask_followup_question` 工具主动启动任务交接过程，然后使用 `new_task` 工具。你必须使用 `new_task` 工具。

通过严格遵循这些指南，你将确保任务之间的平滑过渡，保持项目势头，并为从事复杂、多会话项目的用户提供最佳体验。

```markdown
## 用户交互和工作流考虑

-   **线性流程：** 当前，使用 `new_task` 创建线性序列。旧任务结束，新任务开始。旧任务历史保持可访问以进行回溯。
-   **用户批准：** 你始终拥有控制权，批准交接并有机会修改 Cline 建议携带的上下文。
-   **灵活性：** 核心 `new_task` 工具是一个灵活的构建块。使用 `.clinerules` 进行实验，创建最适合你需求的工作流，无论是用于严格的上下文管理、任务分解还是其他创造性用途。
```
